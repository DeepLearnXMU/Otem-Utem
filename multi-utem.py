#! /usr/bin/python
# -*- coding: utf-8 -*-

import argparse
import os
import sys
import math

from collections import defaultdict
from utils import *

# The strategy to obtain the value for each (candidate, {reference}) pair,
def get_ngram_mismatch(total_ngram_count, mismatch_ngram_count, 
        match_strategy="min", 
        reference_length_strategy="max"):
    '''
        We set match_strategy to be "min" and reference_length_strategy to be "max" in default.
        Because both cases assume the optimistic result.
    '''
    mismatch_value, total_value = 0, 0

    match_strategy_list = common_strategies(mismatch_ngram_count)
    reference_length_strategy_list = common_strategies(total_ngram_count)

    if match_strategy in match_strategy_list:
        mismatch_value = match_strategy_list[match_strategy]
    else:
        print >> sys.stderr, 'ERROR: unsupported strategy for under-translation match'
        sys.exit(1)

    if reference_length_strategy in reference_length_strategy_list:
        total_value = reference_length_strategy_list[reference_length_strategy]
    else:
        print >> sys.stderr, 'ERROR: unsupported strategy for reference n-gram count'
        sys.exit(1)

    return mismatch_value, total_value


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='under-translation evaluation metric (UTEM) on multiple references.')
    parser.add_argument('-lc', help='Lowercase, i.e case-insensitive setting', action='store_true')
    parser.add_argument('-ms', help='under-translation match strategy', default='min')
    parser.add_argument('-rls', help='the strategy for the selection of reference length', default='max')
    parser.add_argument('-v', help='print other useful information in the calculation procedure', action="store_true")
    parser.add_argument('candidate', help='Reads the candidate generated by MT system')
    parser.add_argument('reference', help='Reads the references from reference or reference0, reference1, ...')

    args = parser.parse_args()

    cand = args.candidate
    refs = get_refs(args.reference)
    match_strategy, reference_length_strategy, verbose = args.ms, args.rls, args.v

    cand_sentences = read(cand, args.lc)
    refs_sentences = [read(ref, args.lc) for ref in refs]

    assert len(cand_sentences) == len(refs_sentences[0]), \
        'ERROR: the length of candidate and reference must be the same.'

    length_candidate = 0        # total length of candidate
    length_reference = 0        # total length of references, determined by the "match_strategy"
    total_ngram_count_per_corpus, mismatch_ngram_count_per_corpus = defaultdict(int), defaultdict(int)

    # scan all sentences in the corpus
    for trs_idx, cand_sentence in enumerate(cand_sentences):
        length_cand_sentence = len(cand_sentence)
        if verbose:
            print '%d. candidate: %s' %(trs_idx + 1, " ".join(cand_sentence))

        # get all n-grams in current candidate from n = 1...4
        cand_ngrams = get_ngram_list(cand_sentence)
        length_candidate += length_cand_sentence

        lengths_of_all_references = []  # length list of the references corresponding to current candidate
        total_ngram_count_per_sentence, mismatch_ngram_count_per_sentence = defaultdict(list), defaultdict(list)

        # scan all references corresponding to current candidate
        for ref_idx, ref_sentences in enumerate(refs_sentences):
            reference = ref_sentences[trs_idx]  # current reference

            length_ref_sentence = len(reference)
            lengths_of_all_references.append(length_ref_sentence)

            ref_ngrams = get_ngram_list(reference)  # get all n-grams in current reference from n = 1...4
            total_ngram_count_per_reference, mismatch_ngram_count_per_reference = defaultdict(int), defaultdict(int)

            # count the number of under-translation n-grams in current candidate compared with current reference
            for ngram in ref_ngrams:
                n = len(ngram.split())

                ref_ngram_count = ref_ngrams[ngram]  # the number of occurrences of n-gram in current reference
                total_ngram_count_per_reference[n] += ref_ngram_count

                # case 1: current n-gram doesn't appear in the candidate at all
                if ngram not in cand_ngrams:
                    mismatch_ngram_count_per_reference[n] += ref_ngram_count
                elif ref_ngram_count > cand_ngrams[ngram]:
                    # case 2: the n-gram occurs in both reference and candidate, but the occurrence is more in reference
                    mismatch_ngram_count_per_reference[n] += ref_ngram_count - cand_ngrams[ngram]

            if verbose:
                print 'ref%d: %s' % (ref_idx, " ".join(reference))
                print 'mismatch n-gram count: [n=1: %d; n=2: %d; n=3: %d; n=4: %d]' % \
                                        (mismatch_ngram_count_per_reference[1],
                                         mismatch_ngram_count_per_reference[2],
                                         mismatch_ngram_count_per_reference[3],
                                         mismatch_ngram_count_per_reference[4])
                print 'total n-gram count: [n=1: %d; n=2: %d; n=3: %d; n=4: %d]' % \
                                        (total_ngram_count_per_reference[1],
                                         total_ngram_count_per_reference[2],
                                         total_ngram_count_per_reference[3],
                                         total_ngram_count_per_reference[4])

            for n in total_ngram_count_per_reference:
                total_ngram_count_per_sentence[n].append(total_ngram_count_per_reference[n])
                mismatch_ngram_count_per_sentence[n].append(mismatch_ngram_count_per_reference[n])

        # get the match length and the reference index that corresponding to
        length_reference += get_length_reference(lengths_of_all_references, length_cand_sentence)

        for n in total_ngram_count_per_sentence:
            m, t = get_ngram_mismatch(total_ngram_count_per_sentence[n], mismatch_ngram_count_per_sentence[n],
                                           match_strategy, reference_length_strategy)
            mismatch_ngram_count_per_corpus[n] += m
            total_ngram_count_per_corpus[n] += t

        if verbose:
            print 'with match strategy: %s and reference length strategy: %s' % (match_strategy, reference_length_strategy)
            print 'final mismatch n-gram count: [n=1: %d; n=2: %d; n=3: %d; n=4: %d]' % \
                                        (mismatch_ngram_count_per_corpus[1],
                                         mismatch_ngram_count_per_corpus[2],
                                         mismatch_ngram_count_per_corpus[3],
                                         mismatch_ngram_count_per_corpus[4])
            print 'final total n-gram count: [n=1: %d; n=2: %d; n=3: %d; n=4: %d]' % \
                                        (total_ngram_count_per_corpus[1],
                                         total_ngram_count_per_corpus[2],
                                         total_ngram_count_per_corpus[3],
                                         total_ngram_count_per_corpus[4])
            print '--------------------------------------------------------------------------------------------------'

    length_penalty = 1
    utem = 0
    
    multi_utem = defaultdict(int)
    for n in xrange(1, 5):
        if n in total_ngram_count_per_corpus:
            multi_utem[n] += mismatch_ngram_count_per_corpus[n] * 1. / total_ngram_count_per_corpus[n]

    if length_reference == 0:
        print >> sys.stderr, "UTEM = 0, 0/0/0/0 (LP=0, ratio=0, hyp_len=0, ref_len=0)"
        sys.exit(1);

    # Under-translation: candidates perfered to be shorter, so penalize short translations
    if length_candidate <= length_reference:
        length_penalty = math.exp(1. - length_candidate*1./length_reference)

    # normal UTEM-4 metric
    utem = length_penalty * math.exp((safe_log(multi_utem[1]) +
                                      safe_log(multi_utem[2]) +
                                      safe_log(multi_utem[3]) +
                                      safe_log(multi_utem[4])) / 4.)

    print >> sys.stderr, "UTEM = %.2f, %.1f/%.1f/%.1f/%.1f (LP=%.3f, ratio=%.3f, hyp_len=%d, ref_len=%d)" % (
        100*utem,
        100*multi_utem[1],
        100*multi_utem[2],
        100*multi_utem[3],
        100*multi_utem[4],
        length_penalty*1.,
        length_candidate*1. / length_reference,
        length_candidate,
        length_reference)
